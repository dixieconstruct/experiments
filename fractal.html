<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Fractal Zoom</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: monospace;
        }
        
        canvas {
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }
        
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #fff;
            text-decoration: none;
            font-size: 1.2em;
            z-index: 100;
            text-shadow: 0 0 5px #000;
        }
        
        #info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #fff;
            font-size: 12px;
            text-shadow: 0 0 5px #000;
            z-index: 100;
        }
        
        #crosshair {
            position: fixed;
            pointer-events: none;
            z-index: 50;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê</a>
    <canvas id="canvas"></canvas>
    <div id="crosshair"></div>
    <div id="info">Tap to set zoom target | Zoom: <span id="zoom">1</span>x</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const crosshair = document.getElementById('crosshair');
        const zoomEl = document.getElementById('zoom');
        
        // High DPI support
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Mandelbrot state
        let centerX = -0.5;
        let centerY = 0;
        let zoom = 1;
        let targetX = centerX;
        let targetY = centerY;
        
        // Zoom speed
        const ZOOM_SPEED = 1.008;
        
        // Color palette
        function getColor(iter, maxIter) {
            if (iter === maxIter) return [0, 0, 0];
            
            const t = iter / maxIter;
            const angle = t * 6.28318 * 3;
            
            const r = Math.sin(angle) * 127 + 128;
            const g = Math.sin(angle + 2.094) * 127 + 128;
            const b = Math.sin(angle + 4.188) * 127 + 128;
            
            return [r, g, b];
        }
        
        // Render Mandelbrot
        function render() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            const aspectRatio = width / height;
            const viewWidth = 3.5 / zoom;
            const viewHeight = viewWidth / aspectRatio;
            
            const xMin = centerX - viewWidth / 2;
            const yMin = centerY - viewHeight / 2;
            
            const maxIter = Math.min(500, 100 + Math.log2(zoom) * 30);
            
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const x0 = xMin + (px / width) * viewWidth;
                    const y0 = yMin + (py / height) * viewHeight;
                    
                    let x = 0, y = 0;
                    let iter = 0;
                    
                    while (x*x + y*y <= 4 && iter < maxIter) {
                        const xTemp = x*x - y*y + x0;
                        y = 2*x*y + y0;
                        x = xTemp;
                        iter++;
                    }
                    
                    const [r, g, b] = getColor(iter, maxIter);
                    const idx = (py * width + px) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Animation loop
        let lastRender = 0;
        const RENDER_INTERVAL = 50;
        
        function animate() {
            const now = performance.now();
            
            // Smoothly move center toward target
            centerX += (targetX - centerX) * 0.02;
            centerY += (targetY - centerY) * 0.02;
            
            // Continuous zoom
            zoom *= ZOOM_SPEED;
            
            // Throttle rendering
            if (now - lastRender > RENDER_INTERVAL) {
                render();
                lastRender = now;
                
                // Update zoom display
                if (zoom >= 1e9) {
                    zoomEl.textContent = (zoom / 1e9).toFixed(1) + 'B';
                } else if (zoom >= 1e6) {
                    zoomEl.textContent = (zoom / 1e6).toFixed(1) + 'M';
                } else if (zoom >= 1e3) {
                    zoomEl.textContent = (zoom / 1e3).toFixed(1) + 'K';
                } else {
                    zoomEl.textContent = zoom.toFixed(1);
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // Handle clicks/taps
        function setTarget(clientX, clientY) {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspectRatio = width / height;
            const viewWidth = 3.5 / zoom;
            const viewHeight = viewWidth / aspectRatio;
            
            const xMin = centerX - viewWidth / 2;
            const yMin = centerY - viewHeight / 2;
            
            targetX = xMin + (clientX / width) * viewWidth;
            targetY = yMin + (clientY / height) * viewHeight;
            
            // Move crosshair
            crosshair.style.left = clientX + 'px';
            crosshair.style.top = clientY + 'px';
        }
        
        canvas.addEventListener('click', (e) => {
            setTarget(e.clientX, e.clientY);
        });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            setTarget(touch.clientX, touch.clientY);
        });
        
        // Start centered
        crosshair.style.left = window.innerWidth / 2 + 'px';
        crosshair.style.top = window.innerHeight / 2 + 'px';
        
        // Initial render and start animation
        render();
        animate();
    </script>
</body>
</html>
