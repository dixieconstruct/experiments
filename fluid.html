<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ASCII Fluid</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #0f0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            font-family: monospace;
        }
        
        #fluid {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 12px;
            letter-spacing: 1px;
            white-space: pre;
            cursor: crosshair;
            padding: 20px;
            user-select: none;
            touch-action: none;
            margin: 0 auto;
        }
        
        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #0a0;
            text-decoration: none;
            font-size: 1.2em;
            z-index: 100;
        }
        
        #info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #060;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">←</a>
    <pre id="fluid"></pre>
    <div id="info">Click/tap to drop rocks</div>

    <script>
        const fluidEl = document.getElementById('fluid');
        
        // Grid size
        const COLS = 70;
        const ROWS = 35;
        
        // Wave state (height and velocity)
        let height = [];
        let velocity = [];
        
        // ASCII chars for different slopes
        // Center = flat, others show direction of slope
        const FLAT = '~';
        const CHARS = {
            flat: '~·.',
            up: '^\'`',
            down: 'v,.',
            left: '\\<(',
            right: '/)>',
            upLeft: '\\`╲',
            upRight: '/\'╱',
            downLeft: '\\,╲',
            downRight: '/,╱'
        };
        
        // Initialize
        function init() {
            for (let i = 0; i < COLS * ROWS; i++) {
                height[i] = 0;
                velocity[i] = 0;
            }
        }
        
        function idx(x, y) {
            return y * COLS + x;
        }
        
        // Drop a rock - creates a depression that bounces back
        function dropRock(x, y, radius, strength) {
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist <= radius) {
                        const px = Math.floor(x + dx);
                        const py = Math.floor(y + dy);
                        if (px >= 0 && px < COLS && py >= 0 && py < ROWS) {
                            const i = idx(px, py);
                            const falloff = Math.cos((dist / radius) * Math.PI / 2);
                            height[i] -= strength * falloff;
                        }
                    }
                }
            }
        }
        
        // Wave equation simulation
        function simulate() {
            const damping = 0.99;
            const speed = 0.4;
            
            const newHeight = new Float32Array(COLS * ROWS);
            const newVelocity = new Float32Array(COLS * ROWS);
            
            for (let y = 1; y < ROWS - 1; y++) {
                for (let x = 1; x < COLS - 1; x++) {
                    const i = idx(x, y);
                    
                    // Laplacian (average of neighbors minus center)
                    const laplacian = (
                        height[idx(x-1, y)] + height[idx(x+1, y)] +
                        height[idx(x, y-1)] + height[idx(x, y+1)]
                    ) / 4 - height[i];
                    
                    // Wave equation: acceleration proportional to curvature
                    newVelocity[i] = (velocity[i] + laplacian * speed) * damping;
                    newHeight[i] = height[i] + newVelocity[i];
                }
            }
            
            // Boundary reflection (edges push back)
            for (let x = 0; x < COLS; x++) {
                newHeight[idx(x, 0)] = newHeight[idx(x, 1)] * 0.8;
                newHeight[idx(x, ROWS-1)] = newHeight[idx(x, ROWS-2)] * 0.8;
            }
            for (let y = 0; y < ROWS; y++) {
                newHeight[idx(0, y)] = newHeight[idx(1, y)] * 0.8;
                newHeight[idx(COLS-1, y)] = newHeight[idx(COLS-2, y)] * 0.8;
            }
            
            height = newHeight;
            velocity = newVelocity;
        }
        
        // Render to ASCII based on slope
        function render() {
            let output = '';
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const i = idx(x, y);
                    const h = height[i];
                    
                    // Calculate slope (gradient)
                    let dx = 0, dy = 0;
                    if (x > 0 && x < COLS - 1) {
                        dx = height[idx(x+1, y)] - height[idx(x-1, y)];
                    }
                    if (y > 0 && y < ROWS - 1) {
                        dy = height[idx(x, y+1)] - height[idx(x, y-1)];
                    }
                    
                    const threshold = 0.015;
                    const strongThreshold = 0.04;
                    const veryStrongThreshold = 0.08;
                    
                    let char = '·';  // Default calm water
                    
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);
                    
                    if (absDx < threshold && absDy < threshold) {
                        // Flat - show ripple based on height
                        if (h > 0.08) char = '○';
                        else if (h > 0.04) char = '◦';
                        else if (h < -0.08) char = '•';
                        else if (h < -0.04) char = '∘';
                        else if (Math.abs(h) > 0.01) char = '~';
                        else char = '·';
                    } else if (absDx > absDy * 1.5) {
                        // Mostly horizontal slope
                        if (dx > veryStrongThreshold) char = '《';
                        else if (dx > strongThreshold) char = '\\';
                        else if (dx > threshold) char = '(';
                        else if (dx < -veryStrongThreshold) char = '》';
                        else if (dx < -strongThreshold) char = '/';
                        else if (dx < -threshold) char = ')';
                    } else if (absDy > absDx * 1.5) {
                        // Mostly vertical slope
                        if (dy > veryStrongThreshold) char = '≡';
                        else if (dy > strongThreshold) char = '=';
                        else if (dy > threshold) char = '-';
                        else if (dy < -veryStrongThreshold) char = '≡';
                        else if (dy < -strongThreshold) char = '=';
                        else if (dy < -threshold) char = '-';
                    } else {
                        // Diagonal slopes
                        if (dx > 0 && dy > 0) char = absDx > strongThreshold ? '╲' : '`';
                        else if (dx > 0 && dy < 0) char = absDx > strongThreshold ? '╱' : '\'';
                        else if (dx < 0 && dy > 0) char = absDx > strongThreshold ? '╱' : '\'';
                        else if (dx < 0 && dy < 0) char = absDx > strongThreshold ? '╲' : '`';
                    }
                    
                    output += char;
                }
                output += '\n';
            }
            fluidEl.textContent = output;
        }
        
        // Input handling
        let lastDragTime = 0;
        const DRAG_THROTTLE = 100; // ms between drag drops
        
        function handleInput(clientX, clientY, isDrag = false) {
            const rect = fluidEl.getBoundingClientRect();
            const charWidth = rect.width / COLS;
            const charHeight = rect.height / ROWS;
            
            const x = (clientX - rect.left) / charWidth;
            const y = (clientY - rect.top) / charHeight;
            
            if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                if (isDrag) {
                    const now = performance.now();
                    if (now - lastDragTime < DRAG_THROTTLE) return;
                    lastDragTime = now;
                    dropRock(x, y, 2, 0.5); // Smaller, gentler drops when dragging
                } else {
                    dropRock(x, y, 3, 0.8); // Full rock on click
                }
            }
        }
        
        fluidEl.addEventListener('mousedown', (e) => {
            handleInput(e.clientX, e.clientY, false);
        });
        
        fluidEl.addEventListener('mousemove', (e) => {
            if (e.buttons === 1) {
                handleInput(e.clientX, e.clientY, true);
            }
        });
        
        fluidEl.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (const touch of e.touches) {
                handleInput(touch.clientX, touch.clientY, false);
            }
        });
        
        fluidEl.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (const touch of e.touches) {
                handleInput(touch.clientX, touch.clientY, true);
            }
        });
        
        // Main loop
        function loop() {
            simulate();
            render();
            requestAnimationFrame(loop);
        }
        
        init();
        loop();
    </script>
</body>
</html>
