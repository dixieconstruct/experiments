<!DOCTYPE html>
<html>
<head>
    <title>Heart Rate Monitor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 100%);
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            touch-action: none;
        }
        h1 { margin-bottom: 10px; font-size: 1.5em; }
        .subtitle { color: #666; font-size: 0.9em; margin-bottom: 20px; }
        
        #video-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            aspect-ratio: 4/3;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        video, #overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }
        video { transform: scaleX(-1); }
        #overlay { pointer-events: none; }
        
        #roi-box {
            position: absolute;
            border: 2px solid rgba(255, 100, 100, 0.8);
            background: rgba(255, 100, 100, 0.1);
            border-radius: 8px;
            pointer-events: none;
        }
        
        #bpm-display {
            font-size: 4em;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
            margin: 20px 0;
        }
        #bpm-display span { font-size: 0.4em; color: #888; }
        
        #signal-container {
            width: 100%;
            max-width: 500px;
            height: 150px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        #signal-canvas { width: 100%; height: 100%; }
        
        #status {
            color: #888;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 20px;
        }
        
        button {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.5);
            color: #ff6b6b;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover {
            background: rgba(255, 107, 107, 0.3);
        }
        
        #instructions {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            z-index: 10;
        }
        #instructions.hidden { display: none; }
        
        .back-link {
            position: fixed;
            top: 15px;
            left: 15px;
            color: #666;
            text-decoration: none;
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">←</a>
    <h1>❤️ Heart Rate Monitor</h1>
    <p class="subtitle">Tap your forehead or cheek area to start</p>
    
    <div id="video-container">
        <video id="video" autoplay playsinline></video>
        <canvas id="overlay"></canvas>
        <div id="roi-box" style="display:none;"></div>
        <div id="instructions">
            <p>Tap to start camera</p>
        </div>
    </div>
    
    <div id="bpm-display">-- <span>BPM</span></div>
    
    <div id="signal-container">
        <canvas id="signal-canvas"></canvas>
    </div>
    
    <div id="status">Waiting for camera...</div>
    
    <button id="reset-btn" style="display:none;">Reset ROI</button>

    <script>
        const video = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const overlayCtx = overlay.getContext('2d');
        const signalCanvas = document.getElementById('signal-canvas');
        const signalCtx = signalCanvas.getContext('2d');
        const bpmDisplay = document.getElementById('bpm-display');
        const statusEl = document.getElementById('status');
        const roiBox = document.getElementById('roi-box');
        const instructions = document.getElementById('instructions');
        const resetBtn = document.getElementById('reset-btn');
        const videoContainer = document.getElementById('video-container');
        
        let stream = null;
        let roi = null;
        let rawSignal = [];
        let filteredSignal = [];
        let timestamps = [];
        let currentBPM = null;
        let isRunning = false;
        
        const BUFFER_SIZE = 256;
        const MIN_HZ = 0.7;  // 42 BPM
        const MAX_HZ = 4.0;  // 240 BPM
        
        // Resize canvases
        function resizeCanvases() {
            const rect = videoContainer.getBoundingClientRect();
            overlay.width = rect.width;
            overlay.height = rect.height;
            signalCanvas.width = signalCanvas.parentElement.clientWidth;
            signalCanvas.height = signalCanvas.parentElement.clientHeight;
        }
        window.addEventListener('resize', resizeCanvases);
        
        // Start camera
        async function startCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } }
                });
                video.srcObject = stream;
                await video.play();
                instructions.classList.add('hidden');
                statusEl.textContent = 'Tap on your forehead or cheek to select region';
                resizeCanvases();
            } catch (err) {
                statusEl.textContent = 'Camera error: ' + err.message;
            }
        }
        
        // Handle tap to select ROI
        videoContainer.addEventListener('click', async (e) => {
            if (!stream) {
                await startCamera();
                return;
            }
            
            const rect = videoContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Mirror x coordinate to match video
            const mirroredX = rect.width - x;
            
            // ROI size (relative to container)
            const size = Math.min(rect.width, rect.height) * 0.25;
            
            roi = {
                x: mirroredX - size/2,
                y: y - size/2,
                width: size,
                height: size,
                // For sampling (in video coordinates)
                videoX: (mirroredX / rect.width) * video.videoWidth,
                videoY: (y / rect.height) * video.videoHeight,
                videoW: (size / rect.width) * video.videoWidth,
                videoH: (size / rect.height) * video.videoHeight
            };
            
            // Show ROI box (mirrored back for display)
            roiBox.style.display = 'block';
            roiBox.style.left = (rect.width - roi.x - roi.width) + 'px';
            roiBox.style.top = roi.y + 'px';
            roiBox.style.width = roi.width + 'px';
            roiBox.style.height = roi.height + 'px';
            
            resetBtn.style.display = 'block';
            rawSignal = [];
            filteredSignal = [];
            timestamps = [];
            isRunning = true;
            statusEl.textContent = 'Measuring... hold still';
            requestAnimationFrame(processFrame);
        });
        
        resetBtn.addEventListener('click', () => {
            roi = null;
            roiBox.style.display = 'none';
            resetBtn.style.display = 'none';
            isRunning = false;
            rawSignal = [];
            filteredSignal = [];
            timestamps = [];
            bpmDisplay.innerHTML = '-- <span>BPM</span>';
            statusEl.textContent = 'Tap on your forehead or cheek to select region';
        });
        
        // Process video frame
        function processFrame() {
            if (!isRunning || !roi) return;
            
            // Draw video to overlay canvas to sample pixels
            overlayCtx.drawImage(video, 0, 0, overlay.width, overlay.height);
            
            // Sample ROI
            const imageData = overlayCtx.getImageData(
                roi.videoX * (overlay.width / video.videoWidth),
                roi.videoY * (overlay.height / video.videoHeight),
                roi.videoW * (overlay.width / video.videoWidth),
                roi.videoH * (overlay.height / video.videoHeight)
            );
            
            // Calculate average green channel
            let greenSum = 0;
            let count = 0;
            for (let i = 0; i < imageData.data.length; i += 4) {
                greenSum += imageData.data[i + 1]; // Green channel
                count++;
            }
            const avgGreen = greenSum / count;
            
            const now = performance.now();
            rawSignal.push(avgGreen);
            timestamps.push(now);
            
            // Keep buffer size limited
            while (rawSignal.length > BUFFER_SIZE) {
                rawSignal.shift();
                timestamps.shift();
            }
            
            // Need enough samples
            if (rawSignal.length >= 64) {
                // Detrend signal (remove DC and slow drift)
                const detrended = detrend(rawSignal);
                
                // Apply bandpass filter
                const filtered = bandpassFilter(detrended, timestamps);
                filteredSignal = filtered;
                
                // Estimate BPM using zero-crossing or peak detection
                if (filtered.length >= 64) {
                    const bpm = estimateBPM(filtered, timestamps);
                    if (bpm) {
                        currentBPM = currentBPM ? currentBPM * 0.8 + bpm * 0.2 : bpm;
                        bpmDisplay.innerHTML = Math.round(currentBPM) + ' <span>BPM</span>';
                        statusEl.textContent = 'Signal detected - hold still for accuracy';
                    }
                }
            }
            
            // Draw signal graph
            drawSignal();
            
            // Clear overlay (we just used it for sampling)
            overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
            
            requestAnimationFrame(processFrame);
        }
        
        // Remove linear trend from signal
        function detrend(signal) {
            const n = signal.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            for (let i = 0; i < n; i++) {
                sumX += i;
                sumY += signal[i];
                sumXY += i * signal[i];
                sumX2 += i * i;
            }
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return signal.map((v, i) => v - (slope * i + intercept));
        }
        
        // Simple bandpass using moving averages
        function bandpassFilter(signal, times) {
            if (signal.length < 10) return signal;
            
            // Estimate sample rate
            const duration = (times[times.length-1] - times[0]) / 1000;
            const sampleRate = signal.length / duration;
            
            // High-pass: subtract slow moving average (removes < 0.7 Hz)
            const slowWindow = Math.round(sampleRate / MIN_HZ);
            const highPassed = [];
            for (let i = 0; i < signal.length; i++) {
                const start = Math.max(0, i - slowWindow);
                const end = i + 1;
                const avg = signal.slice(start, end).reduce((a,b) => a+b, 0) / (end - start);
                highPassed.push(signal[i] - avg);
            }
            
            // Low-pass: smooth with fast moving average (removes > 4 Hz)
            const fastWindow = Math.max(2, Math.round(sampleRate / MAX_HZ / 2));
            const lowPassed = [];
            for (let i = 0; i < highPassed.length; i++) {
                const start = Math.max(0, i - fastWindow);
                const end = Math.min(highPassed.length, i + fastWindow + 1);
                const avg = highPassed.slice(start, end).reduce((a,b) => a+b, 0) / (end - start);
                lowPassed.push(avg);
            }
            
            return lowPassed;
        }
        
        // Estimate BPM from filtered signal
        function estimateBPM(signal, times) {
            if (signal.length < 30) return null;
            
            const duration = (times[times.length-1] - times[0]) / 1000;
            const sampleRate = signal.length / duration;
            
            // Find peaks
            const peaks = [];
            for (let i = 2; i < signal.length - 2; i++) {
                if (signal[i] > signal[i-1] && signal[i] > signal[i+1] &&
                    signal[i] > signal[i-2] && signal[i] > signal[i+2]) {
                    // Check if it's a significant peak
                    const localMax = Math.max(...signal.slice(Math.max(0,i-10), i+10));
                    const localMin = Math.min(...signal.slice(Math.max(0,i-10), i+10));
                    if (signal[i] > localMin + (localMax - localMin) * 0.5) {
                        peaks.push(i);
                    }
                }
            }
            
            if (peaks.length < 2) return null;
            
            // Calculate average interval between peaks
            let totalInterval = 0;
            let validIntervals = 0;
            for (let i = 1; i < peaks.length; i++) {
                const interval = (peaks[i] - peaks[i-1]) / sampleRate;
                const bpm = 60 / interval;
                // Only count reasonable intervals
                if (bpm >= 42 && bpm <= 240) {
                    totalInterval += interval;
                    validIntervals++;
                }
            }
            
            if (validIntervals === 0) return null;
            
            const avgInterval = totalInterval / validIntervals;
            return 60 / avgInterval;
        }
        
        // Draw signal visualization
        function drawSignal() {
            const ctx = signalCtx;
            const w = signalCanvas.width;
            const h = signalCanvas.height;
            
            ctx.fillStyle = 'rgba(15, 15, 26, 0.3)';
            ctx.fillRect(0, 0, w, h);
            
            const signal = filteredSignal.length > 0 ? filteredSignal : rawSignal;
            if (signal.length < 2) return;
            
            // Normalize signal
            const min = Math.min(...signal);
            const max = Math.max(...signal);
            const range = max - min || 1;
            
            // Draw waveform
            ctx.beginPath();
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < signal.length; i++) {
                const x = (i / signal.length) * w;
                const y = h - ((signal[i] - min) / range) * h * 0.8 - h * 0.1;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw center line
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, h/2);
            ctx.lineTo(w, h/2);
            ctx.stroke();
        }
        
        // Initial draw
        resizeCanvases();
        drawSignal();
    </script>
</body>
</html>
